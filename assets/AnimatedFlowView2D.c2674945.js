import{m as f,r as y,q as u,e9 as m,b6 as b,b8 as x,ba as S,bb as C,X as $,a9 as l,aa as h,ab as w,a7 as v,E as M,aj as j,cP as L,K as _,H as z}from"./vendor.f5642644.js";import{p as A}from"./dataUtils.f3a330de.js";import{a as O,c as T}from"./WGLContainer.96b23cd9.js";import{I as F}from"./Utils.cc4850d4.js";import{a as P}from"./Container.46e88f89.js";import{o as D,f as W}from"./VertexArrayObject.e0a1a120.js";import"./Texture.36d56722.js";class I extends O{constructor(){super(...arguments),this.flowStyle=null}get requiresDedicatedFBO(){return!1}doRender(e){super.doRender(e)}prepareRenderPasses(e){const t=e.registerRenderPass({name:"flow",brushes:[T],target:()=>this.children,drawPhase:F.MAP});return[...super.prepareRenderPasses(e),t]}}const q=f.getLogger("esri.views.2d.engine.flow.FlowDisplayData");class V{constructor(e,t,a,n){this.state={name:"created"},this.flowStyle=e,this.extent=t,this.size=a,this.pixelRatio=n}async load(){const e=new AbortController;this.state={name:"loading",abortController:e};const t=await this.flowStyle.loadResources({extent:this.extent,size:this.size,pixelRatio:this.pixelRatio},e.signal);this.state={name:"loaded",resources:t}}prepareForRendering(e,t,a){if(this.state.name!=="loaded")return void q.error("Only loaded resources can be attached.");const n=this.state.resources;n.prepareForRendering(e,t,a),this.state={name:"attached",resources:n}}destroy(){if(this.state.name==="loading")return this.state.abortController.abort(),void(this.state={name:"detached"});this.state.name==="attached"&&(this.state.resources.detach(),this.state={name:"detached"})}update(e){return this.flowStyle.areResourcesCompatible(e.flowStyle)?!(!this.extent.equals(e.extent)||this.size[0]!==e.size[0]||this.size[1]!==e.size[1]||this.pixelRatio!==e.pixelRatio)&&(this.flowStyle=e.flowStyle,!0):!1}}class B extends P{constructor(){super(...arguments),this._displayData=null}get displayData(){return this._displayData}set displayData(e){this._displayData=e,this.requestRender()}clear(){y(this._displayData)&&(this._displayData.destroy(),this._displayData=null,this.requestRender())}setTransform(e){const{displayData:t}=this;if(u(t))return;const a=t.extent.xmin,n=t.extent.ymax,o=[0,0];e.toScreen(o,[a,n]);const r=(t.extent.xmax-t.extent.xmin)/t.size[0]/e.resolution,d=m(e.rotation),{dvs:s}=this.transforms;b(s),x(s,s,[-1,1,0]),S(s,s,[2/(e.size[0]*e.pixelRatio),-2/(e.size[1]*e.pixelRatio),1]),x(s,s,[o[0],o[1],0]),C(s,s,d),S(s,s,[r*e.pixelRatio,r*e.pixelRatio,1])}_createTransforms(){return{dvs:$()}}}const U=1.15,E=f.getLogger("esri.views.2d.engine.flow.FlowStrategy");let p=class extends v{constructor(i){super(i),this._flowDisplayObject=new B,this._loading=null}initialize(){this.flowContainer.addChild(this._flowDisplayObject)}destroy(){this._clear(),this.flowContainer.removeAllChildren()}get updating(){return this._loading!=null}update(i){const{flowStyle:e}=this.flowContainer;if(u(e))return void this._clear();const{extent:t,rotation:a,resolution:n,pixelRatio:o}=i.state,r=H(t,a);r.expand(U);const d=[Math.round((r.xmax-r.xmin)/n),Math.round((r.ymax-r.ymin)/n)],s=new V(e,r,d,o);if(y(this._loading)){if(this._loading.update(s))return;this._loading.destroy(),this._loading=null}!u(this._flowDisplayObject.displayData)&&this._flowDisplayObject.displayData.update(s)||(s.load().then(()=>{this._flowDisplayObject.clear(),this._flowDisplayObject.displayData=this._loading,this._loading=null},g=>{M(g)||(E.error("A resource failed to load.",g),this._loading=null)}),this._loading=s)}_clear(){this._flowDisplayObject.clear(),y(this._loading)&&(this._loading.destroy(),this._loading=null)}};l([h()],p.prototype,"_loading",void 0),l([h()],p.prototype,"flowContainer",void 0),l([h()],p.prototype,"updating",null),p=l([w("esri.views.2d.engine.flow.FlowStrategy")],p);const G=p;function H(i,e){const t=new j({x:(i.xmax+i.xmin)/2,y:(i.ymax+i.ymin)/2,spatialReference:i.spatialReference}),a=i.xmax-i.xmin,n=i.ymax-i.ymin,o=Math.abs(Math.cos(m(e))),r=Math.abs(Math.sin(m(e))),d=o*a+r*n,s=r*a+o*n,g=new L({xmin:t.x-d/2,ymin:t.y-s/2,xmax:t.x+d/2,ymax:t.y+s/2,spatialReference:i.spatialReference});return g.centerAt(t),g}function K(i){const e=_(i.lineWidth),t=2*e,a=Math.round(_(i.lineLength)/t)+1,n=e,o=10,r=i.lineColor.toRgba(),d=[r[0]/255,r[1]/255,r[2]/255,r[3]],{lineSpeed:s,fadeDuration:g,density:R}=i;return{lineRenderWidth:e,segmentLength:t,verticesPerLine:a,lineCollisionWidth:n,lineSpacing:o,lineColor:d,lineSpeed:s,fadeDuration:g,density:R,smoothing:_(i.smoothing),velocityScale:1,minWeightThreshold:.001,minSpeedThreshold:.001,maxTurnAngle:1,mergeLines:!0,interpolate:!0,profile:!1}}class X{constructor(e,t){this._vertexData=e,this._indexData=t}prepareForRendering(e,t,a){const n=D.createVertex(e,35044,this._vertexData),o=D.createIndex(e,35044,this._indexData),r=new W(e,t,a,{geometry:n},o);this.vertexBuffer=n,this.indexBuffer=o,this.vertexArray=r,this._vertexData=null,this._indexData=null}detach(){this.vertexArray.dispose(),this.vertexBuffer.dispose(),this.indexBuffer.dispose()}}class k{constructor(e,t,a){this._loadImagery=e,this._createStreamlinesMesh=t,this._rendererSettings=K(a)}get animated(){return this._rendererSettings.lineSpeed>0}get renderSettings(){return this._rendererSettings}areResourcesCompatible(e){let t=!0;return t=t&&e._loadImagery===this._loadImagery,t=t&&e._createStreamlinesMesh===this._createStreamlinesMesh,t=t&&e._rendererSettings.verticesPerLine===this._rendererSettings.verticesPerLine,t=t&&e._rendererSettings.segmentLength===this._rendererSettings.segmentLength,t=t&&e._rendererSettings.lineSpacing===this._rendererSettings.lineSpacing,t=t&&e._rendererSettings.density===this._rendererSettings.density,t=t&&e._rendererSettings.smoothing===this._rendererSettings.smoothing,t=t&&e._rendererSettings.velocityScale===this._rendererSettings.velocityScale,t=t&&e._rendererSettings.minWeightThreshold===this._rendererSettings.minWeightThreshold,t=t&&e._rendererSettings.minSpeedThreshold===this._rendererSettings.minSpeedThreshold,t=t&&e._rendererSettings.mergeLines===this._rendererSettings.mergeLines,t=t&&e._rendererSettings.interpolate===this._rendererSettings.interpolate,t&&this._rendererSettings.mergeLines&&(t=e._rendererSettings.lineCollisionWidth===this._rendererSettings.lineCollisionWidth),!!t}async loadResources(e,t){const{extent:a,size:n}=e;z(t);const o=await this._loadImagery(a,n[0],n[1],t),{vertexData:r,indexData:d}=await this._createStreamlinesMesh(this._rendererSettings,o,t);return new X(r,d)}}let c=class extends v{constructor(){super(...arguments),this._loadImagery=(i,e,t,a)=>A(this.layer,i,e,t,a),this._createStreamlinesMesh=(i,e,t)=>this.layer.createStreamlinesMesh({flowData:e,rendererSettings:i},{signal:t}),this.container=null,this.layer=null,this.type="rasterAnimatedFlow",this.redrawOrRefetch=async()=>{this._rendererChanged()}}get updating(){return!this._strategy||this._strategy.updating}update(i){i.stationary?this._strategy.update(i):this.layerView.requestUpdate()}install(i){this.container=new I,i.addChild(this.container),this._strategy=new G({flowContainer:this.container}),this._rendererChanged()}uninstall(){this._strategy.destroy(),this.container.removeAllChildren(),this.container.remove()}moveEnd(){}async doRefresh(){}attach(){}_rendererChanged(){if(this.layer.renderer.type!=="animated-flow")return;const i=new k(this._loadImagery,this._createStreamlinesMesh,this.layer.renderer);this.container.flowStyle=i,this.layerView.requestUpdate()}};l([h()],c.prototype,"_strategy",void 0),l([h()],c.prototype,"container",void 0),l([h()],c.prototype,"layer",void 0),l([h()],c.prototype,"layerView",void 0),l([h()],c.prototype,"type",void 0),l([h()],c.prototype,"updating",null),c=l([w("esri.views.2d.engine.flow.AnimatedFlowView2D")],c);const ie=c;export{ie as p};
