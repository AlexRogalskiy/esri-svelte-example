import{a9 as f,aa as y,ab as v,cs as I,cO as w,cH as S,bO as $,aj as P,cP as Y}from"./vendor.f5642644.js";let x=class extends I{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};f([y()],x.prototype,"affectsPixelSize",null),f([y({json:{write:!0}})],x.prototype,"spatialReference",void 0),x=f([v("esri.layers.support.rasterTransforms.BaseRasterTransform")],x);const g=x;let d=class extends g{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(e){return(e=e.clone()).type==="point"?(e.x>180+this.tolerance&&(e.x-=360),e):(e.xmin>=180-this.tolerance?(e.xmax-=360,e.xmin-=360):e.xmax>180+this.tolerance&&(e.xmin=-180,e.xmax=180),e)}inverseTransform(e){return(e=e.clone()).type==="point"?(e.x<-this.tolerance&&(e.x+=360),e):(e.xmin<-this.tolerance&&(e.xmin+=360,e.xmax+=360),e)}};f([w({GCSShiftXform:"gcs-shift"})],d.prototype,"type",void 0),f([y()],d.prototype,"tolerance",void 0),d=f([v("esri.layers.support.rasterTransforms.GCSShiftTransform")],d);const M=d;let C=class extends g{constructor(){super(...arguments),this.type="identity"}};f([w({IdentityXform:"identity"})],C.prototype,"type",void 0),C=f([v("esri.layers.support.rasterTransforms.IdentityTransform")],C);const z=C;function T(e,s,o){const{x:t,y:n}=s;if(o<2)return{x:e[0]+t*e[2]+n*e[4],y:e[1]+t*e[3]+n*e[5]};if(o===2){const p=t*t,X=n*n,O=t*n;return{x:e[0]+t*e[2]+n*e[4]+p*e[6]+O*e[8]+X*e[10],y:e[1]+t*e[3]+n*e[5]+p*e[7]+O*e[9]+X*e[11]}}const r=t*t,a=n*n,u=t*n,i=r*t,m=r*n,h=t*a,l=n*a;return{x:e[0]+t*e[2]+n*e[4]+r*e[6]+u*e[8]+a*e[10]+i*e[12]+m*e[14]+h*e[16]+l*e[18],y:e[1]+t*e[3]+n*e[5]+r*e[7]+u*e[9]+a*e[11]+i*e[13]+m*e[15]+h*e[17]+l*e[19]}}function R(e,s,o){const{xmin:t,ymin:n,xmax:r,ymax:a,spatialReference:u}=s;let i=[];if(o<2)i.push({x:t,y:a}),i.push({x:r,y:a}),i.push({x:t,y:n}),i.push({x:r,y:n});else{let l=10;for(let p=0;p<l;p++)i.push({x:t,y:n+(a-n)*p/(l-1)}),i.push({x:r,y:n+(a-n)*p/(l-1)});l=8;for(let p=1;p<=l;p++)i.push({x:t+(r-t)*p/l,y:n}),i.push({x:t+(r-t)*p/l,y:a})}i=i.map(l=>T(e,l,o));const m=i.map(l=>l.x),h=i.map(l=>l.y);return new Y({xmin:Math.min.apply(null,m),xmax:Math.max.apply(null,m),ymin:Math.min.apply(null,h),ymax:Math.max.apply(null,h),spatialReference:u})}function F(e){const[s,o,t,n,r,a]=e,u=t*a-r*n,i=r*n-t*a;return[(r*o-s*a)/u,(t*o-s*n)/i,a/u,n/i,-r/u,-t/i]}let c=class extends g{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,s){const{coeffX:o,coeffY:t}=s;if(o==null||!o.length||t==null||!t.length||o.length!==t.length)return null;const n=[];for(let r=0;r<o.length;r++)n.push(o[r]),n.push(t[r]);return n}writeForwardCoefficients(e,s,o){const t=[],n=[];for(let r=0;r<(e==null?void 0:e.length);r++)r%2==0?t.push(e[r]):n.push(e[r]);s.coeffX=t,s.coeffY=n}get inverseCoefficients(){let e=this._get("inverseCoefficients");const s=this._get("forwardCoefficients");return!e&&s&&this.polynomialOrder<2&&(e=F(s)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,s){const{inverseCoeffX:o,inverseCoeffY:t}=s;if(o==null||!o.length||t==null||!t.length||o.length!==t.length)return null;const n=[];for(let r=0;r<o.length;r++)n.push(o[r]),n.push(t[r]);return n}writeInverseCoefficients(e,s,o){const t=[],n=[];for(let r=0;r<(e==null?void 0:e.length);r++)r%2==0?t.push(e[r]):n.push(e[r]);s.inverseCoeffX=t,s.inverseCoeffY=n}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if(e.type==="point"){const s=T(this.forwardCoefficients,e,this.polynomialOrder);return new P({x:s.x,y:s.y,spatialReference:e.spatialReference})}return R(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if(e.type==="point"){const s=T(this.inverseCoefficients,e,this.polynomialOrder);return new P({x:s.x,y:s.y,spatialReference:e.spatialReference})}return R(this.inverseCoefficients,e,this.polynomialOrder)}};f([y({json:{write:!0}})],c.prototype,"polynomialOrder",void 0),f([y()],c.prototype,"forwardCoefficients",void 0),f([S("forwardCoefficients",["coeffX","coeffY"])],c.prototype,"readForwardCoefficients",null),f([$("forwardCoefficients")],c.prototype,"writeForwardCoefficients",null),f([y({json:{write:!0}})],c.prototype,"inverseCoefficients",null),f([S("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],c.prototype,"readInverseCoefficients",null),f([$("inverseCoefficients")],c.prototype,"writeInverseCoefficients",null),f([y()],c.prototype,"affectsPixelSize",null),f([w({PolynomialXform:"polynomial"})],c.prototype,"type",void 0),c=f([v("esri.layers.support.rasterTransforms.PolynomialTransform")],c);const b=c,j={GCSShiftXform:M,IdentityXform:z,PolynomialXform:b},G=Object.keys(j);function k(e){const s=e==null?void 0:e.type;return!e||G.includes(s)}function B(e){if(!(e==null?void 0:e.type))return null;const s=j[e==null?void 0:e.type];if(s){const o=new s;return o.read(e),o}return null}export{M as c,k as e,B as f,b as m};
